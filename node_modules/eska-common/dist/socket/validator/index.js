"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const z_schema_1 = __importDefault(require("z-schema"));
const message_1 = require("../validator/schema/message");
const message_2 = require("../model/message");
const response_1 = require("../model/response");
const util_1 = require("../util");
/**
 * Compile all schemas for validate
 */
const validator = new z_schema_1.default({
    noTypeless: true,
    noExtraKeywords: true,
    noEmptyArrays: true,
    noEmptyStrings: true
});
const isSchemasValid = validator.validateSchema([
    message_1.HEADER_MESSAGE_SCHEMA,
    message_1.MESSAGE_SCHEMA,
]);
if (!isSchemasValid) {
    throw new Error('Invalid validation schema');
}
exports.validate = (type) => {
    return (_target, _propertyName, descriptor) => {
        let descriptorFn = descriptor.value || descriptor.get();
        return {
            value: (message, socket) => {
                const callback = (errors, isValid) => {
                    if (!isValid) {
                        const errorMessage = [`Invalid arguments`, ...errors.map(err => err.message)];
                        if (message.headers && message.headers.id) {
                            message.headers.type = message_2.MessageType.RESPONSE;
                            message.body = new response_1.ResponseEntity({
                                errors: errorMessage
                            });
                        }
                        else {
                            const responseBody = new response_1.ResponseEntity({ errors: errorMessage });
                            message = new message_2.Message(message_2.MessageType.RESPONSE, 'ERROR', responseBody);
                        }
                        util_1.sendData(socket, message, type);
                        return;
                    }
                    return descriptorFn.call(this, message, socket);
                };
                validator.validate(message, 'message', callback);
            },
        };
    };
};
//# sourceMappingURL=index.js.map